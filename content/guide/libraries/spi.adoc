++++
<style>
.container {
    width: 960px;
    position: relative;
    margin: 0;
    z-index:1;

}

.ulist li {
  margin: -0.5em;
}

#first {
    width: 210px;
    float: left;
    position: fixed;
    border-right: 1px dotted lightgray;

}

#second {
    width: 740px;
    float: right;
    overflow: hidden;
}
</style>

<div class='container'>
    <div id="first">
++++

Functions

* link:../spi/spi_begin[begin()]
* link:../spi/spi_end[end()]
* link:../spi/spi_setbitorder[setBitOrder()]
* link:../spi/spi_setclockdivider[setClockDivider()]
* link:../spi/spi_setdatamode[setDataMode()]
* link:../spi/spi_transfer[transfer()]
* link:../spi/spi_setmodule[setModule()]
++++
    </div>
    <div id="second">
++++

## SPI Library


This library allows you to communicate with SPI devices, with the
Energia target board as the master device.

### A Brief Introduction to the Serial Peripheral Interface (SPI)

Serial Peripheral Interface (SPI) is a synchronous serial data protocol
used by microcontrollers for communicating with one or more peripheral
devices quickly over short distances. It can also be used for
communication between two microcontrollers. With an SPI connection there
is always one master device (usually a microcontroller) which controls
the peripheral devices. Typically there are three lines common to all
the devices:

* **MISO** (Master In Slave Out) - The Slave line for sending data to
    the master,
* **MOSI** (Master Out Slave In) - The Master line for sending data to
    the peripherals,
* **SCK** (Serial Clock) - The clock pulses which synchronize data
    transmission generated by the master

and one line specific for every device:

* **SS** (Slave Select) - the pin on each device that the master can
    use to enable and disable specific devices.

When a device's Slave Select pin is low, it communicates with the master. When it's high, it ignores the master. This allows you to have multiple SPI devices sharing the same MISO, MOSI, and CLK lines. To write code for a new SPI device you need to note a few things:

* Is data shifted in Most Significant Bit (MSB) or Least Significant Bit (LSB) first? This is controlled by the **SPI.setBitOrder()** function.
* Is the data clock idle when high or low? Are samples on the rising or falling edge of clock pulses? These modes are controlled by the **SPI.setDataMode()** function.
* What speed is the SPI running at? This is controlled by the **SPI.setClockDivider()** function.

The SPI standard is loose and each device implements it a little
differently. This means you have to pay special attention to the
device's datasheet when writing your code. Generally speaking, there are
four modes of transmission. These modes control whether data is shifted
in and out on the rising or falling edge of the data clock signal
(called the clock **phase**), and whether the clock is idle when high or
low (called the clock **polarity**). The four modes combine polarity and
phase according to this table:

  ------------ --------------------------- ------------------------
  **Mode**     **Clock Polarity (CPOL)**   **Clock Phase (CPHA)**
  SPI\_MODE0   0                           0
  SPI\_MODE1   0                           1
  SPI\_MODE2   1                           0
  SPI\_MODE3   1                           1
  ------------ --------------------------- ------------------------

The `SPI.setDataMode()` function lets you set the mode to control clock
polarity and phase. Every SPI device has a maximum allowed speed for SPI
Bus. The SPI.setClockDivider() allows you to change the clock speed to
make your device working properly (default is 4MHz). Once you have your
SPI parameters set correctly you just need to figure which registers in
your device control which functions, and you're good to go. This will be
explained in the data sheet for your device. For more on SPI, see
http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_Numbers[Wikipedia's page on SPI]

### Connections

Refer to the Pin Maps for each board to locate where the SPI pins.
Across LaunchPads the pins are mostly standardized (see the http://ti.com/byob[TI
BoosterPack Standard]) but a few boards have
variations.


#### Note about Slave Select (SS) pin

Most microntrollers have an SS pin that is useful when they act as a
**slave** controlled by an external master. Since this library supports
only master mode, this pin should be set always as OUTPUT otherwise the
SPI interface could be put automatically into slave mode by hardware,
rendering the library inoperative. It is, however, possible to use any
pin as the Slave Select (SS) for the devices.

### Examples

* http://arduino.cc/en/Tutorial/BarometricPressureSensor[BarometricPressureSensor]
    Read air pressure and temperature from a sensor using SPI
* http://arduino.cc/en/Tutorial/SPIDigitalPot[SPIDigitalPot]
    Control a digital potentiometer using SPI

++++
    </div>
</div>
++++
